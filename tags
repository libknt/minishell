!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_OUTPUT_EXCMD	mixed	/number, pattern, mixed, or combineV2/
!_TAG_OUTPUT_FILESEP	slash	/slash or backslash/
!_TAG_OUTPUT_MODE	u-ctags	/u-ctags or e-ctags/
!_TAG_PATTERN_LENGTH_LIMIT	96	/0 for no limit/
!_TAG_PROC_CWD	/home/masahitoarai/Documents/minishell#14/	//
!_TAG_PROGRAM_AUTHOR	Universal Ctags Team	//
!_TAG_PROGRAM_NAME	Universal Ctags	/Derived from Exuberant Ctags/
!_TAG_PROGRAM_URL	https://ctags.io/	/official site/
!_TAG_PROGRAM_VERSION	5.9.0	//
$(NAME)	Makefile	/^$(NAME):$(OBJS)$/;"	t
$(OBJDIR)/%.o	Makefile	/^$(OBJDIR)\/%.o: %.c$/;"	t
CC	Makefile	/^CC			=	cc$/;"	m
CFLAGS	Makefile	/^CFLAGS		=	-Wall -Wextra -Werror$/;"	m
CMDLINE	include/struct.h	/^	CMDLINE,$/;"	e	enum:e_redirect
EOF	test.sh	/^cat << EOF | gcc -xc -o a.out -$/;"	h
FILENAME	include/struct.h	/^	FILENAME,$/;"	e	enum:e_redirect
GET_NEXT_LINE_H	include/get_next_line.h	/^# define GET_NEXT_LINE_H$/;"	d
INCLUDE	Makefile	/^INCLUDE		=	-I .\/include\/$/;"	m
MAX	include/get_next_line.h	/^# define MAX /;"	d
MAX_FD	include/get_next_line.h	/^# define MAX_FD /;"	d
MINISHELL_H	include/minishell.h	/^# define MINISHELL_H$/;"	d
NAME	Makefile	/^NAME 		=	minishell$/;"	m
OBJDIR	Makefile	/^OBJDIR   = obj$/;"	m
OBJS	Makefile	/^OBJS  = $(addprefix $(OBJDIR)\/, $(SRCS:.c=.o))$/;"	m
OP	include/struct.h	/^	OP,$/;"	e	enum:e_token_type
PATH_MAXLEN	srcs/buildin/cd.c	/^#define PATH_MAXLEN /;"	d	file:
PIPE	include/struct.h	/^	PIPE,$/;"	e	enum:e_redirect
READ	srcs/exe/exe.c	/^#define READ /;"	d	file:
READ	tmp/exe.c	/^#define READ /;"	d	file:
READ	tmp/redi/here_documents.c	/^#define READ /;"	d	file:
REDIRECT	include/struct.h	/^	REDIRECT,$/;"	e	enum:e_redirect
RESERVED	include/struct.h	/^	RESERVED,$/;"	e	enum:e_token_type
SRCS	Makefile	/^SRCS		= $(shell find srcs\/ -name "*.c" )$/;"	m
STRUCT_H	include/struct.h	/^# define STRUCT_H$/;"	d
T_EOF	include/struct.h	/^	T_EOF,$/;"	e	enum:e_token_type
T_EOF_R	include/struct.h	/^	T_EOF_R,$/;"	e	enum:e_redirect
WORD	include/struct.h	/^	WORD,$/;"	e	enum:e_token_type
WRITE	srcs/exe/exe.c	/^#define WRITE /;"	d	file:
WRITE	tmp/exe.c	/^#define WRITE /;"	d	file:
WRITE	tmp/redi/here_documents.c	/^#define WRITE /;"	d	file:
_err	srcs/err/_err.c	/^void	_err(const char *e)$/;"	f	typeref:typename:void
_err_arg	srcs/main.c	/^void	_err_arg(int argc, char **argv)$/;"	f	typeref:typename:void
_err_cmd_node_found	srcs/exe/exe.c	/^static void	_err_cmd_node_found(char *mes)$/;"	f	typeref:typename:void	file:
_err_cmd_node_found	srcs/exe/execve_simple_cmd.c	/^static void	_err_cmd_node_found(char *mes)$/;"	f	typeref:typename:void	file:
_err_parse_p	srcs/parser/parse_err_message.c	/^void	_err_parse_p(char *mes, bool *r)$/;"	f	typeref:typename:void
_err_syntax	srcs/lexer/token_error.c	/^bool	_err_syntax(char *mes)$/;"	f	typeref:typename:bool
_err_syntax_p	srcs/parser/parse_err_message.c	/^void	_err_syntax_p(char *mes, bool *r)$/;"	f	typeref:typename:void
_redirect_si	tmp/redi/redirecting.c	/^void	_redirect_si(t_node *node)$/;"	f	typeref:typename:void
access_cmd_path	srcs/exe/exe.c	/^static char	**access_cmd_path(t_node *node, char **envp)$/;"	f	typeref:typename:char **	file:
access_cmd_path	srcs/exe/execve_simple_cmd.c	/^static char	**access_cmd_path(t_node *node, char **envp)$/;"	f	typeref:typename:char **	file:
add_env	srcs/environ/make_lstenvp.c	/^void	add_env(t_env **env, char *envp, size_t len)$/;"	f	typeref:typename:void
add_node	srcs/parser/parser_utils.c	/^t_node	**add_node(t_node *node)$/;"	f	typeref:typename:t_node **
add_value	srcs/environ/make_lstenvp.c	/^void	add_value(t_env **env, char *envp, size_t len)$/;"	f	typeref:typename:void
addline	srcs/parser/parser_line.c	/^void	addline(t_token *token, t_line **line, t_line *new, int type)$/;"	f	typeref:typename:void
addline_utils	srcs/parser/parser_line_utils.c	/^void	addline_utils(t_line **line, t_token *token, t_redirect type)$/;"	f	typeref:typename:void
all	Makefile	/^all: $(NAME)$/;"	t
assert	test.sh	/^assert()$/;"	f
buildin	srcs/buildin/buildin.c	/^int	buildin(char *argv[], t_env **env)$/;"	f	typeref:typename:int
calc_expand_len	srcs/environ/expand.c	/^ssize_t	calc_expand_len(char *line, t_env *env, ssize_t len)$/;"	f	typeref:typename:ssize_t
cd	srcs/buildin/cd.c	/^int	cd(char *argv[], t_env *env)$/;"	f	typeref:typename:int
check_env_vari	srcs/buildin/export.c	/^int	check_env_vari(char *argv)$/;"	f	typeref:typename:int
check_eql	srcs/buildin/env.c	/^bool check_eql(char *str)$/;"	f	typeref:typename:bool
check_line	srcs/parser/parse_err.c	/^void	check_line(t_line *line, bool *r)$/;"	f	typeref:typename:void
check_syntax	srcs/parser/parse_err.c	/^void	check_syntax(t_node *node, bool *r)$/;"	f	typeref:typename:void
clean	Makefile	/^clean:$/;"	t
continue_read	tmp/lexer.c	/^void	continue_read(bool *sq, bool *dq, char **line)$/;"	f	typeref:typename:void
ctr_c	srcs/signal/signal.c	/^void	ctr_c(int sig)$/;"	f	typeref:typename:void
dq	include/struct.h	/^	bool					dq;$/;"	m	struct:s_data_t	typeref:typename:bool
e_redirect	include/struct.h	/^enum						e_redirect$/;"	g
e_token_type	include/struct.h	/^enum						e_token_type$/;"	g
env_buildin	srcs/buildin/env.c	/^void	env_buildin(char *argv[], t_env *env)$/;"	f	typeref:typename:void
env_last	srcs/environ/make_lstenvp.c	/^t_env	*env_last(t_env *env)$/;"	f	typeref:typename:t_env *
env_len	srcs/environ/make_lstenvp.c	/^size_t	env_len(char *envp)$/;"	f	typeref:typename:size_t
env_num	srcs/buildin/export.c	/^ssize_t	env_num(t_env *env)$/;"	f	typeref:typename:ssize_t
env_sort	srcs/buildin/export.c	/^char	**env_sort(char **envp)$/;"	f	typeref:typename:char **
err_syntax	srcs/lexer/token_error.c	/^bool	err_syntax(char *op)$/;"	f	typeref:typename:bool
escape_fd	tmp/redi/redirecting.c	/^static int	escape_fd(int fd)$/;"	f	typeref:typename:int	file:
exe_	srcs/exe/exe.c	/^int	exe_(t_node *node, t_env *env)$/;"	f	typeref:typename:int
exe_	tmp/exe.c	/^int	exe_(t_node *node)$/;"	f	typeref:typename:int
exec	srcs/exe/exe.c	/^int	exec(t_node *node, t_env *env, int fd1)$/;"	f	typeref:typename:int
exec	tmp/exe.c	/^int	exec(t_node *node, int k3)$/;"	f	typeref:typename:int
exec_filename	srcs/exe/exec_filename.c	/^char	*exec_filename(char *prompt, char **envp)$/;"	f	typeref:typename:char *
exec_si	tmp/exe.c	/^int	exec_si(t_node *node)$/;"	f	typeref:typename:int
exec_tree	srcs/exe/exe.c	/^int	exec_tree(t_node *node, t_env *env)$/;"	f	typeref:typename:int
exec_tree	tmp/exe.c	/^int	exec_tree(t_node *node)$/;"	f	typeref:typename:int
execve_simple_cmd	srcs/exe/execve_simple_cmd.c	/^int	execve_simple_cmd(t_node *node, t_env *env)$/;"	f	typeref:typename:int
exit_status	srcs/main.c	/^int	exit_status;$/;"	v	typeref:typename:int
expand	tmp/lexer2/expand.c	/^void	expand(t_token *token)$/;"	f	typeref:typename:void
expand_quote	srcs/environ/expand.c	/^char	*expand_quote(char *line)$/;"	f	typeref:typename:char *
expand_token	srcs/environ/expand.c	/^void	expand_token(t_token **token, t_env *env)$/;"	f	typeref:typename:void
fclean	Makefile	/^fclean: clean$/;"	t
fd	include/struct.h	/^	int						fd;$/;"	m	struct:s_fd	typeref:typename:int
fd	include/struct.h	/^	t_fd					*fd;$/;"	m	struct:s_node	typeref:typename:t_fd *
files.associations	.vscode/settings.json	/^	"files.associations": {$/;"	o
find_env	srcs/environ/expand.c	/^char	*find_env(char *str, t_env *env)$/;"	f	typeref:typename:char *
find_env_len	srcs/environ/expand.c	/^ssize_t	find_env_len(char *str, t_env *env)$/;"	f	typeref:typename:ssize_t
find_redirect	srcs/parser/parser.c	/^bool	find_redirect(t_token *token)$/;"	f	typeref:typename:bool
find_type	srcs/lexer/lexer.c	/^t_token_type	find_type(char *tmp)$/;"	f	typeref:typename:t_token_type
find_type	tmp/lexer.c	/^t_token_type	find_type(char *tmp)$/;"	f	typeref:typename:t_token_type
free_envp	srcs/buildin/export.c	/^char	**free_envp(char **envp, ssize_t len)$/;"	f	typeref:typename:char **
ft_env_addback	srcs/environ/make_lstenvp.c	/^void	ft_env_addback(t_env **env, t_env *new)$/;"	f	typeref:typename:void
ft_exit	srcs/buildin/exit.c	/^void	ft_exit(char **argv)$/;"	f	typeref:typename:void
ft_export	srcs/buildin/export.c	/^void	ft_export(char *argv[], t_env **env)$/;"	f	typeref:typename:void
ft_get_split	srcs/exe/exec_filename.c	/^static char	**ft_get_split(char **dst, char const *s, char c)$/;"	f	typeref:typename:char **	file:
ft_join_free	tmp/lexer.c	/^char	*ft_join_free(char *s1, char *s2, int flag1, int flag2)$/;"	f	typeref:typename:char *
ft_split	srcs/exe/exec_filename.c	/^char	**ft_split(char const *s, char c)$/;"	f	typeref:typename:char **
ft_split_free	srcs/exe/exec_filename.c	/^void	ft_split_free(char **dst)$/;"	f	typeref:typename:void
ft_split_len	srcs/exe/exec_filename.c	/^static size_t	ft_split_len(char const *s, char c)$/;"	f	typeref:typename:size_t	file:
ft_split_size	srcs/exe/exec_filename.c	/^static size_t	ft_split_size(char const *s, char c)$/;"	f	typeref:typename:size_t	file:
ft_strdup	srcs/exe/exec_filename.c	/^char	*ft_strdup(const char *s1)$/;"	f	typeref:typename:char *
ft_strjoin	srcs/exe/exec_filename.c	/^char	*ft_strjoin(char const *s1, char const *s2)$/;"	f	typeref:typename:char *
ft_strlcat	srcs/exe/exec_filename.c	/^size_t	ft_strlcat(char *dst, const char *src, size_t dstsize)$/;"	f	typeref:typename:size_t
ft_strlcpy	srcs/exe/exec_filename.c	/^size_t	ft_strlcpy(char *dst, const char *src, size_t dstsize)$/;"	f	typeref:typename:size_t
ft_substr	srcs/exe/exec_filename.c	/^char	*ft_substr(char const *s, unsigned int start, size_t len)$/;"	f	typeref:typename:char *
get_home_dir	srcs/buildin/cd.c	/^char	*get_home_dir(t_env *env)$/;"	f	typeref:typename:char *
head	include/struct.h	/^	t_token					*head;$/;"	m	struct:s_data_t	typeref:typename:t_token *
here_doc	tmp/redi/here_documents.c	/^int	here_doc(t_node *node)$/;"	f	typeref:typename:int
here_doc_exe	tmp/redi/here_documents.c	/^int	here_doc_exe(char *end)$/;"	f	typeref:typename:int
here_documents	tmp/redi/here_documents.c	/^int	here_documents(t_node *node)$/;"	f	typeref:typename:int
i	include/struct.h	/^	size_t					i;$/;"	m	struct:s_data_t	typeref:typename:size_t
is_alpha_num_under	srcs/environ/expand.c	/^bool	is_alpha_num_under(char c)$/;"	f	typeref:typename:bool
is_alpha_under	srcs/environ/expand.c	/^bool	is_alpha_under(char c)$/;"	f	typeref:typename:bool
is_blank	srcs/lexer/lexer_utils_is.c	/^bool	is_blank(char c)$/;"	f	typeref:typename:bool
is_blank	tmp/lexer.c	/^bool	is_blank(char c)$/;"	f	typeref:typename:bool
is_buildin	srcs/buildin/buildin.c	/^bool	is_buildin(char *str)$/;"	f	typeref:typename:bool
is_identifier	srcs/environ/expand.c	/^bool	is_identifier(const char *s)$/;"	f	typeref:typename:bool
is_metacharacter	srcs/lexer/lexer_utils_is.c	/^bool	is_metacharacter(char c)$/;"	f	typeref:typename:bool
is_metacharacter	tmp/lexer.c	/^bool	is_metacharacter(char c)$/;"	f	typeref:typename:bool
is_ok	srcs/lexer/lexer_utils_is.c	/^bool	is_ok(char *prompt, size_t len)$/;"	f	typeref:typename:bool
is_ok	tmp/lexer.c	/^bool	is_ok(char *prompt, size_t len)$/;"	f	typeref:typename:bool
is_ope	srcs/lexer/lexer_utils_is.c	/^size_t	is_ope(char *line)$/;"	f	typeref:typename:size_t
is_ope	tmp/lexer.c	/^size_t	is_ope(char *line)$/;"	f	typeref:typename:size_t
is_quote	srcs/environ/expand.c	/^int	is_quote(char c)$/;"	f	typeref:typename:int
is_redirect	srcs/lexer/lexer_utils_is.c	/^size_t	is_redirect(char *line)$/;"	f	typeref:typename:size_t
is_redirect	tmp/lexer.c	/^size_t	is_redirect(char *line)$/;"	f	typeref:typename:size_t
key	include/struct.h	/^	char					*key;$/;"	m	struct:s_env	typeref:typename:char *
leak	Makefile	/^leak :$/;"	t
left	include/struct.h	/^	t_node					*left;$/;"	m	struct:s_node	typeref:typename:t_node *
len	include/struct.h	/^	ssize_t					len;$/;"	m	struct:s_data_t	typeref:typename:ssize_t
lexer	srcs/lexer/lexer.c	/^t_token	*lexer(char **line, t_env *env)$/;"	f	typeref:typename:t_token *
lexer	tmp/lexer.c	/^t_token	*lexer(char **line,t_env *env)$/;"	f	typeref:typename:t_token *
lexer_err_free	srcs/lexer/lexer.c	/^static void	*lexer_err_free(char **line, t_token **token)$/;"	f	typeref:typename:void *	file:
line	include/struct.h	/^	t_line					*line;$/;"	m	struct:s_node	typeref:typename:t_line *
line_addback	srcs/parser/parser_line_utils.c	/^void	line_addback(t_line **head, t_line *new)$/;"	f	typeref:typename:void
line_free	srcs/free/free.c	/^void	line_free(t_line *line)$/;"	f	typeref:typename:void
line_last	srcs/parser/parser_line_utils.c	/^t_line	*line_last(t_line *token)$/;"	f	typeref:typename:t_line *
line_size	srcs/exe/make_arr.c	/^size_t	line_size(t_line *line)$/;"	f	typeref:typename:size_t
main	srcs/main.c	/^int	main(int argc, char **argv, char **envp)$/;"	f	typeref:typename:int
make_abs_path	srcs/buildin/cd.c	/^char	*make_abs_path(char *path, char *argv, char *home)$/;"	f	typeref:typename:char *
make_arr	srcs/exe/make_arr.c	/^char	**make_arr(t_node *node)$/;"	f	typeref:typename:char **
make_env_args	srcs/buildin/env.c	/^char	**make_env_args(t_env *env)$/;"	f	typeref:typename:char **
make_expand	srcs/environ/expand.c	/^ssize_t	make_expand(char *expanded, char *line, t_env *env)$/;"	f	typeref:typename:ssize_t
make_export_args	srcs/buildin/export.c	/^static char	**make_export_args(t_env *env)$/;"	f	typeref:typename:char **	file:
make_fd_struct_r	tmp/redi/redirecting.c	/^static void	make_fd_struct_r(t_node *node, t_line *line)$/;"	f	typeref:typename:void	file:
make_line	srcs/parser/parser_line.c	/^t_line	*make_line(t_token *token)$/;"	f	typeref:typename:t_line *
make_lstenv	srcs/environ/make_lstenvp.c	/^void	make_lstenv(t_env **s_env, char **envp)$/;"	f	typeref:typename:void
make_token	srcs/lexer/lexer.c	/^bool	make_token(char **line, t_data_t *d)$/;"	f	typeref:typename:bool
make_token	tmp/lexer.c	/^t_token	*make_token(char **line)$/;"	f	typeref:typename:t_token *
make_tree	srcs/parser/parser.c	/^void	make_tree(t_node **node, t_token *token)$/;"	f	typeref:typename:void
new_fd_num	tmp/redi/redirecting.c	/^static void	new_fd_num(t_line *line, int *fd, int *oldfd)$/;"	f	typeref:typename:void	file:
new_lstenv	srcs/environ/make_lstenvp.c	/^t_env	*new_lstenv(char *envp)$/;"	f	typeref:typename:t_env *
new_token	srcs/lexer/token.c	/^t_token	*new_token(char *str, t_token_type type)$/;"	f	typeref:typename:t_token *
new_token	tmp/lexer.c	/^t_token	*new_token(char *str, t_token_type type)$/;"	f	typeref:typename:t_token *
newfd	include/struct.h	/^	int						newfd;$/;"	m	struct:s_fd	typeref:typename:int
newfd	tmp/redi/redirecting.c	/^t_fd	*newfd(int fd, int oldfd)$/;"	f	typeref:typename:t_fd *
newline	srcs/parser/parser_line_utils.c	/^t_line	*newline(t_token *token, t_redirect type)$/;"	f	typeref:typename:t_line *
newnode	srcs/parser/parser.c	/^t_node	*newnode(t_token *token)$/;"	f	typeref:typename:t_node *
next	include/struct.h	/^	t_env					*next;$/;"	m	struct:s_env	typeref:typename:t_env *
next	include/struct.h	/^	t_line					*next;$/;"	m	struct:s_line	typeref:typename:t_line *
next	include/struct.h	/^	t_node					*next;$/;"	m	struct:s_node	typeref:typename:t_node *
next	include/struct.h	/^	t_token					*next;$/;"	m	struct:s_token	typeref:typename:t_token *
node_addtree	srcs/parser/parser.c	/^void	node_addtree(t_node **node, t_node *new)$/;"	f	typeref:typename:void
num_	tmp/lexer.c	/^size_t	num_(bool *dq, bool *sq, char *tmp)$/;"	f	typeref:typename:size_t
oldfd	include/struct.h	/^	int						oldfd;$/;"	m	struct:s_fd	typeref:typename:int
parse_err	srcs/parser/parse_err.c	/^bool	parse_err(t_node *node)$/;"	f	typeref:typename:bool
parser	srcs/parser/parser.c	/^t_node	*parser(t_token *token, char *line)$/;"	f	typeref:typename:t_node *
prev	include/struct.h	/^	t_env					*prev;$/;"	m	struct:s_env	typeref:typename:t_env *
print_env	srcs/environ/make_lstenvp.c	/^void	print_env(t_env *env)$/;"	f	typeref:typename:void
print_env1	srcs/main.c	/^void	print_env1(t_env *env)$/;"	f	typeref:typename:void
print_fd	tmp/redi/redirecting.c	/^void	print_fd(t_fd *fd)$/;"	f	typeref:typename:void
print_line	srcs/print.c	/^void	print_line(t_line *line)$/;"	f	typeref:typename:void
print_n	srcs/print.c	/^void	print_n(t_node *node)$/;"	f	typeref:typename:void
print_node	srcs/print.c	/^void	print_node(t_node *node)$/;"	f	typeref:typename:void
print_nodes	srcs/exe/exe.c	/^void	print_nodes(t_node *node)$/;"	f	typeref:typename:void
print_split	srcs/print.c	/^void	print_split(char **t)$/;"	f	typeref:typename:void
print_t	srcs/print.c	/^void	print_t(t_token *token)$/;"	f	typeref:typename:void
print_tree	srcs/print.c	/^void	print_tree(t_node *node)$/;"	f	typeref:typename:void
prompt	include/struct.h	/^	char					*prompt;$/;"	m	struct:s_data_t	typeref:typename:char *
push_arr	srcs/exe/make_arr.c	/^void	push_arr(char **arr, t_line *line)$/;"	f	typeref:typename:void
qq_flag	srcs/lexer/lexer_utils_quote.c	/^void	qq_flag(bool *sq, bool *dq, char c)$/;"	f	typeref:typename:void
qq_flag	tmp/lexer.c	/^void	qq_flag(bool *sq, bool *dq, char c)$/;"	f	typeref:typename:void
quate_flag	srcs/lexer/lexer_utils_quote.c	/^bool	quate_flag(char *prompt, size_t *len, bool *dq, bool *sq)$/;"	f	typeref:typename:bool
quate_flag	tmp/lexer.c	/^bool	quate_flag(char *prompt, size_t *len, bool *dq, bool *sq)$/;"	f	typeref:typename:bool
quate_wordlen	tmp/lexer.c	/^size_t	quate_wordlen(bool *dq, bool *sq, size_t i, char **line)$/;"	f	typeref:typename:size_t
re	Makefile	/^re : fclean all$/;"	t
readline.h	.vscode/settings.json	/^		"readline.h": "c",$/;"	s	object:files.associations
readline_quate	tmp/lexer.c	/^char	*readline_quate(bool *dq, bool *sq)$/;"	f	typeref:typename:char *
remake_token	tmp/lexer2/expand.c	/^void	remake_token(t_token *token)$/;"	f	typeref:typename:void
restore_fd	tmp/redi/redirecting.c	/^void	restore_fd(t_node *node)$/;"	f	typeref:typename:void
right	include/struct.h	/^	t_node					*right;$/;"	m	struct:s_node	typeref:typename:t_node *
s_data_t	include/struct.h	/^struct						s_data_t$/;"	s
s_env	include/struct.h	/^struct						s_env$/;"	s
s_fd	include/struct.h	/^struct						s_fd$/;"	s
s_line	include/struct.h	/^struct						s_line$/;"	s
s_node	include/struct.h	/^struct						s_node$/;"	s
s_token	include/struct.h	/^struct						s_token$/;"	s
seach_path	srcs/exe/exec_filename.c	/^char	*seach_path(char **envp)$/;"	f	typeref:typename:char *
set_signal	srcs/signal/signal.c	/^void	set_signal(void)$/;"	f	typeref:typename:void
sq	include/struct.h	/^	bool					sq;$/;"	m	struct:s_data_t	typeref:typename:bool
stat.h	.vscode/settings.json	/^		"stat.h": "c"$/;"	s	object:files.associations
syntax_check	srcs/lexer/token_error.c	/^bool	syntax_check(t_token *token)$/;"	f	typeref:typename:bool
syntax_parse	srcs/parser/parse_err.c	/^void	syntax_parse(t_node *node, bool *r)$/;"	f	typeref:typename:void
t	Makefile	/^t :re$/;"	t
t_data_t	include/struct.h	/^typedef struct s_data_t		t_data_t;$/;"	t	typeref:struct:s_data_t
t_env	include/struct.h	/^typedef struct s_env		t_env;$/;"	t	typeref:struct:s_env
t_escape_fd	tmp/exe.c	/^int	t_escape_fd(int fd)$/;"	f	typeref:typename:int
t_fd	include/struct.h	/^typedef struct s_fd			t_fd;$/;"	t	typeref:struct:s_fd
t_line	include/struct.h	/^typedef struct s_line		t_line;$/;"	t	typeref:struct:s_line
t_node	include/struct.h	/^typedef struct s_node		t_node;$/;"	t	typeref:struct:s_node
t_redirect	include/struct.h	/^typedef enum e_redirect		t_redirect;$/;"	t	typeref:enum:e_redirect
t_token	include/struct.h	/^typedef struct s_token		t_token;$/;"	t	typeref:struct:s_token
t_token_type	include/struct.h	/^typedef enum e_token_type	t_token_type;$/;"	t	typeref:enum:e_token_type
token	include/struct.h	/^	t_token					*token;$/;"	m	struct:s_data_t	typeref:typename:t_token *
token	include/struct.h	/^	t_token					*token;$/;"	m	struct:s_line	typeref:typename:t_token *
token_addback	srcs/lexer/token.c	/^void	token_addback(t_token **head, t_token *new)$/;"	f	typeref:typename:void
token_addback	tmp/lexer.c	/^void	token_addback(t_token **head, t_token *new)$/;"	f	typeref:typename:void
token_error	srcs/lexer/token_error.c	/^bool	token_error(t_token *token)$/;"	f	typeref:typename:bool
token_free	srcs/lexer/t_free.c	/^void	token_free(t_token **token)$/;"	f	typeref:typename:void
token_last	srcs/lexer/token.c	/^t_token	*token_last(t_token *token)$/;"	f	typeref:typename:t_token *
token_last	tmp/lexer.c	/^t_token	*token_last(t_token *token)$/;"	f	typeref:typename:t_token *
tree_free	srcs/free/free.c	/^void	tree_free(t_node *tree)$/;"	f	typeref:typename:void
trim_quote	tmp/lexer2/expand.c	/^char	*trim_quote(char *word)$/;"	f	typeref:typename:char *
type	include/struct.h	/^	t_redirect				type;$/;"	m	struct:s_line	typeref:typename:t_redirect
type	include/struct.h	/^	t_token_type			type;$/;"	m	struct:s_token	typeref:typename:t_token_type
unset	srcs/buildin/unset.c	/^void	unset(char *argv[], t_env **env)$/;"	f	typeref:typename:void
value	include/struct.h	/^	char					*value;$/;"	m	struct:s_env	typeref:typename:char *
var	Makefile	/^var:$/;"	t
vari_end	srcs/environ/expand.c	/^ssize_t	vari_end(char *line)$/;"	f	typeref:typename:ssize_t
vari_expand	srcs/environ/expand.c	/^char	*vari_expand(char *line, t_env *env)$/;"	f	typeref:typename:char *
vari_expand_len	srcs/environ/expand.c	/^ssize_t	vari_expand_len(char *line, t_env *env)$/;"	f	typeref:typename:ssize_t
varl	Makefile	/^varl:$/;"	t
wait_process	srcs/exe/exe.c	/^void	wait_process(void)$/;"	f	typeref:typename:void
wait_process	tmp/exe.c	/^void	wait_process(void)$/;"	f	typeref:typename:void
word	include/struct.h	/^	char					*word;$/;"	m	struct:s_data_t	typeref:typename:char *
word	include/struct.h	/^	char					*word;$/;"	m	struct:s_token	typeref:typename:char *
wordlen	srcs/lexer/lexer.c	/^ssize_t	wordlen(char *prompt, t_data_t *d)$/;"	f	typeref:typename:ssize_t
wordlen	tmp/lexer.c	/^size_t	wordlen(char *prompt, char **line, size_t i)$/;"	f	typeref:typename:size_t
